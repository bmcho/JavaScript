<!DOCTYPE html>
<html>  
    <head></head>
    <body>
        <script>    
            /*
                자바스크립트 비트연산 실제로 활용하기!

                myObject와 hasFoo1AndFoo4를 비교하기 위해 16개의 모델 오프젝트를 생성해야한다.
                이러한 방법은 얻는 정보량에 비하여 overhead 가 너무 크다고 느껴짐.
                만약 비교해야 속성이 추가된다면 모델 오프젝트를 두배로 늘려할것이다. 매우 비효울적이다.

                https://velog.io/@jakeseo_me/2019-04-30-1604-%EC%9E%91%EC%84%B1%EB%90%A8-7qjv3gv9ad
            */
            const myObject = {
                foo1 : false,
                foo2 : true,
                foo3 : false,
                foo4 : true
            }
            const hasFoo1andFoo4 = {
                foo1: false,
                foo2: true,
                foo3: false,
                foo4: true
            }


            /*
                JavaScript의 내부의 모든 정수(64bit/9,007,199,254,740,991까지의 수)들은 2진법으로 표기될수 있다.
            */
            (1).toStirng(2);
            // 1

            (2).toString(2);
            // 10

            (3).toString(2);
            // 11

            (4).toString(2);
            // 100

            (3877494).toString(2);
            // 1110110010101001110110
            
            
            /*
                #비트 연산자#
                32비트 기준

                AND : a & b
                    > 대응하는 비트가 모두 1이면 1
                OR : a | b
                    > 대응하는 비트가 모두 1이거나 하나만 1이면 1
                XOR : a ^ b
                    > 대응하는 비트가 서로 다르면 1
                NOT : ~a
                    > 반전된 값을 반환
                왼쪽 시프트 : a << b
                    > a를 (b < 32) 만큼 왼쪽으로 이동하고 0으로 채워넣음
                부호 유지 오른쪽 시프트 : a >> b
                    > a를 (b <32) 만큼 오른쪽으로 이동하고 부호를 유지한다.??
                      
                부호 버림 오른쪽 시프트 : a >>> b
                    > a를 (b <32) 만큼 오른쪽으로 이동하고 부호를 버린다???
                      
                >>, >>>는 예제로 알아보자...
            */
            
            //1. AND
            console.log(2 & 2); // 0010 & 0010 > 2
            console.log(5 & 2); // 0101 & 0010 > 0
            
            //2. OR
            console.log(2 | 2); // 0010 | 0010 > 0010
            console.log(5 | 2); // 0101 | 0010 > 0111
            console.log(7 | 8); // 0111 | 1000 > 1111

            //3. XOR
            console.log(2 ^ 2); // 0010 | 0010 > 0000
            console.log(5 ^ 2); // 0101 | 0010 > 0111
            console.log(7 ^ 8); // 0111 | 1000 > 1111
            console.log(5 ^ 15);// 0101 | 1111 > 1010

            //4. NOT
            console.log(~2); // ~0010 > 1101
            console.log(~5); // ~0101 > 0111
            console.log(~7); // ~0111 > 1111
            console.log(~5); // ~0101 > 1010

            //5. <<
            console.log(2 << 1); // 0010 << 1 > 0100
            console.log(2 << 2); // 0101 << 2 > 1011
            
            //6. >>/ >>>
            console.log(9 >> 2); // 1001 >> 2 > 0010
            console.log(-9 >> 2);  // 1111 1111 1111 0111 >> 2 > 1111 1111 1111 1101
            console.log(-9 >>> 2); // 1111 1111 1111 0111 >>>2 > 0011 1111 1111 1101         
            /*
                >>와>>>의 가장 큰 차이는 1로 채워주냐 안채워주냐의 차이
                >>는 이동하여 생긴 0을 1로 채워줌
            */
        </script>
    </body>
</html>